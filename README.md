- [Introduction](#introduction)
- [Cargo](#cargo)
- [Keywords](#keywords)
- [Scope](#scope)
- [Types](#types)
  - [Scalar types](#scalar-types)
    - [Integers](#integers)
    - [Floats](#floats)
    - [Booleans](#booleans)
    - [Characters](#characters)
  - [Compound types](#compound-types)
    - [Tuple](#tuple)
    - [Array](#array)
- [Functions](#functions)
- [Statements and Expressions](#statements-and-expressions)
- [Compiling](#compiling)
- [Formatting code](#formatting-code)
- [Running code](#running-code)

# Introduction

These are some study notes / a cheat sheet obtained by reading the official Rust book which can be found here: https://doc.rust-lang.org/book/title-page.html.

# Cargo

- New project: `cargo new <package_name>`
- Build: `cargo build (--release)`
- Build & run: `cargo run`
- Just check that code compiles without creating an executable: `cargo check`
- Add external crates in `Cargo.toml` under `[dependencies]`
- `Cargo.lock` keeps track of all dependencies, is autogenerated when building the application and is usually included in version control
- `cargo doc --open` to build documentation of all dependencies locally and open in browser

# Keywords

- `use`: Import library, e.g. `use std::io`
- `let`: Create variable
- `let mut`: Create mutable variable
- `const`: Create constant. MUST be annotated with a type  
  
Complete list: https://doc.rust-lang.org/book/appendix-01-keywords.html

# Scope

- An inner scope can be defined by encapsulating lines in curly brackets `{}`

# Types

## Scalar types

### Integers

- Either signed or unsigned plus the number of bits
- signed: `i8`
- unsigned: `u8`
- signed range: $-(2^{n-1})$ to $2^{n-1}-1$
- unsigned range: $0$ to $2^n-1$
- `isize` and `usize` pick the largest amount of bits possible on the architecture (nowadays mostly 64 bits)

There are numerous ways to write integer literals:

| Type             | Example       |
| ---------------- | ------------- |
| `Decimal`        | `98_222`      |
| `Hex`            | `0xff`        |
| `Octal`          | `0o77`        |
| `Binary`         | `0b1111_0000` | <> |
| `Byte (u8 only)` | `b'A'`        |

Note the underscore to make large integers more readable.

Dividing integers rounds down to the nearest one.


### Floats

- `f32` and `f64` (default)

### Booleans

- `false` or `true`

### Characters

- Specified with single quotes (e.g. `let c = 'z';`)

## Compound types
### Tuple

- Fixed size grouping of values of possibly varying types
- E.g. `let tup: (i32, f64, u8) = (500, 6.4, 1);`
- Can be unpacked similarly to python: `(x, y, z) = tup;`
- Can be accessed with a dot: `tup.1`
- The empty tuple is called the `unit`

### Array
- Every element needs to have the same type
- Fixed length
- E.g. `let a: [i32; 5] = [1, 2, 3, 4, 5];`
- For non-fixed length use the vector type
- Can be initialized with repeating values as follows: `let a = [3; 5];` (5 repetitions of the value 3)
- Accesed with square brackets: `let first = a[0];`

# Functions

- Entrypoint into any module is the `main` function

Example: 
```rust 
fn foo(x: i32) -> i32 {
  5
}
```

# Statements and Expressions

- Statements do NOT return a value
- Expressions DO return a value
- Example of a statement: `let y = 6;`
- Example of an expression: `5 + 6`
- By adding a semicolon to an expression it turns into a statement

This is a valid expression which returns 4:

```rust
{
  let x = 3;
  x+1
}
```

Note the missing semicolon on the second line of the body which makes sure this is an expression.

# Compiling

- `rustc <module_name>.rs`

# Formatting code

- `rustfmt <path_to_file>.rs`

# Running code

- `./<name_of_compiled_module>`
