- [Introduction](#introduction)
- [Cargo](#cargo)
- [Keywords](#keywords)
- [Scope](#scope)
- [Types](#types)
  - [Scalar types](#scalar-types)
    - [Integers](#integers)
    - [Floats](#floats)
    - [Booleans](#booleans)
    - [Characters](#characters)
  - [Compound types](#compound-types)
    - [Tuple](#tuple)
    - [Array](#array)
- [Functions](#functions)
- [Statements and Expressions](#statements-and-expressions)
  - [`if` expressions](#if-expressions)
  - [Loop expression](#loop-expression)
- [Compiling](#compiling)
- [Formatting code](#formatting-code)
- [Running code](#running-code)

# Introduction

These are some study notes / a cheat sheet obtained by reading the official Rust book which can be found here: https://doc.rust-lang.org/book/title-page.html.

# Cargo

- New project: `cargo new <package_name>`
- Build: `cargo build (--release)`
- Build & run: `cargo run`
- Just check that code compiles without creating an executable: `cargo check`
- Add external crates in `Cargo.toml` under `[dependencies]`
- `Cargo.lock` keeps track of all dependencies, is autogenerated when building the application and is usually included in version control
- `cargo doc --open` to build documentation of all dependencies locally and open in browser

# Keywords

- `use`: Import library, e.g. `use std::io`
- `let`: Create variable
- `let mut`: Create mutable variable
- `const`: Create constant. MUST be annotated with a type  
- `continue`: Step over loop iteration.
- `break`: Step out of loop.
  
Complete list: https://doc.rust-lang.org/book/appendix-01-keywords.html

# Scope

- An inner scope can be defined by encapsulating lines in curly brackets `{}`

In general variables that are known at compile time are stored on the stack while variables which aren't are stored on the heap. Retrieving objects from the heap is more expensive than getting them from the stack. To ensure memory safety Rust won't compile the following piece of code:

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

Since both `s2` and `s1` point to the same data in memory, to make sure the same space in memory is not freed twice, `s1` goes out of scope as soon as we assign it to `s2`. This code would work if the statement to create `s2` would explicitly make a deep copy: `let s2 = s1.clone();`

Note that this behaviour is different for variables which are stored on the stack which are automatically deep-copied:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

A function can take ownership of a variable and deallocate it by simply printing it. The following program won't compile:

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);
    println!("{s}")
}
fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}
```


# Types

## Scalar types

### Integers

- Either signed or unsigned plus the number of bits
- signed: `i8`
- unsigned: `u8`
- signed range: $-(2^{n-1})$ to $2^{n-1}-1$
- unsigned range: $0$ to $2^n-1$
- `isize` and `usize` pick the largest amount of bits possible on the architecture (nowadays mostly 64 bits)

There are numerous ways to write integer literals:

| Type             | Example       |
| ---------------- | ------------- |
| `Decimal`        | `98_222`      |
| `Hex`            | `0xff`        |
| `Octal`          | `0o77`        |
| `Binary`         | `0b1111_0000` | <> |
| `Byte (u8 only)` | `b'A'`        |

Note the underscore to make large integers more readable.

Dividing integers rounds down to the nearest one.


### Floats

- `f32` and `f64` (default)

### Booleans

- `false` or `true`

### Characters

- Specified with single quotes (e.g. `let c = 'z';`)

## Compound types
### Tuple

- Fixed size grouping of values of possibly varying types
- E.g. `let tup: (i32, f64, u8) = (500, 6.4, 1);`
- Can be unpacked similarly to python: `(x, y, z) = tup;`
- Can be accessed with a dot: `tup.1`
- The empty tuple is called the `unit`

### Array
- Every element needs to have the same type
- Fixed length
- E.g. `let a: [i32; 5] = [1, 2, 3, 4, 5];`
- For non-fixed length use the vector type
- Can be initialized with repeating values as follows: `let a = [3; 5];` (5 repetitions of the value 3)
- Accesed with square brackets: `let first = a[0];`

# Functions

- Entrypoint into any module is the `main` function

Example: 
```rust 
fn foo(x: i32) -> i32 {
  5
}
```

# Statements and Expressions

- Statements do NOT return a value
- Expressions DO return a value
- Example of a statement: `let y = 6;`
- Example of an expression: `5 + 6`
- By adding a semicolon to an expression it turns into a statement

This is a valid expression which returns 4:

```rust
{
  let x = 3;
  x+1
}
```

Note the missing semicolon on the second line of the body which makes sure this is an expression.

## `if` expressions

```rust
if condition {
  ...;
} else if {
  ...;
} else {
  ...;
}
```

Unlike python the condition HAS to be a bool.

Can be used on the right side of a `let` statement for a ternary condition:

```rust    
let x = 3;
let number = if x > 4 {5} else {10}; 
```

The types of the different branches of the if statement have to be the same. It can't return an integer in one case and a string in another.

## Loop expression

Three types of loops:

- `loop {}`: execute loop until explicitly being told to stop (using `break`)
- `for item in collection {}`
- `while condition {}`

Note that the `break` keyword can be used with a value after it to return a value out of a loop:

```rust
let mut counter = 0;
let result = loop {   
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
```

Loops can be labelled and the `continue` and `break` keywords applied to a labelled loop from inside another loop:

```rust
'some_loop_label' loop {...}
...
break 'some_loop_label'
```
# Compiling

- `rustc <module_name>.rs`

# Formatting code

- `rustfmt <path_to_file>.rs`

# Running code

- `./<name_of_compiled_module>`
